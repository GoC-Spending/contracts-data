# Handler functions to match together amendment groups
# in Government of Canada contracting data

# Note: is it bad form to load these multiple times? Does it cheerfully ignore repeats?
# Update: appears to be, all good.
source("lib/_libraries.R")


# Version 1
# Note: this is spectacularly slow (30+ hours?) on the full contract dataset:
find_amendment_groups_v1 <- function(contracts) {
  # To identify amendment groups, the approach is:
  # same owner_org
  # same vendor (once normalized)
  # same d_procurement_id
  # OR
  # same owner_org
  # same vendor (once normalized)
  # original_value == contract_value of the original row(?)
  # same start date (to confirm if derived values / closest year helps)
  
  # *not* part of an existing amendment group
  
  # New columns added
  # d_is_amendment
  # d_amendment_group_id
  contracts <- contracts %>%
    mutate(
      d_is_amendment = FALSE,
      d_amendment_group_id = NA_character_,
    )
  
  # Amendment finding across all contracts:
  reference_numbers <- contracts %>% pull(d_reference_number)
  
  # Create a temporary array that matches origin contract reference numbers
  # to amendment reference numbers.
  # This would be a nested array of different lengths if we were doing it in PHP!
  amendment_groups <- tibble(origin_reference_number = character(), amendment_reference_number = character())
  
  for (i in seq_along(reference_numbers)) {
    
    # 1. Pull up the current contract
    current_contract <- contracts %>%
      filter(
        d_reference_number == reference_numbers[[i]]
      ) %>%
      slice_head()
    
    # 2A. Find the matching contracts by d_procurement_id
    matching_reference_numbers_by_d_procurement_id <- contracts %>%
      filter(
        d_reference_number != current_contract$d_reference_number, # Don't re-select the same row
        owner_org == current_contract$owner_org,
        d_vendor_name == current_contract$d_vendor_name,
        d_procurement_id == current_contract$d_procurement_id,
        is.na(d_amendment_group_id), # Don't re-run existing amendments
      ) %>%
      pull(d_reference_number)
    
    # 2B. Find the matching contracts by original value and start date
    matching_reference_numbers_by_original_value_and_start_date <- contracts %>%
      filter(
        d_reference_number != current_contract$d_reference_number, # Don't re-select the same row
        owner_org == current_contract$owner_org,
        d_vendor_name == current_contract$d_vendor_name,
        original_value == current_contract$contract_value,
        d_start_date == current_contract$d_start_date, # Note: does normalizing the start date have unexpected consequences here? Do amendments sometimes have new, later, start dates?
        is.na(d_amendment_group_id), # Don't re-run existing amendments
      ) %>%
      pull(d_reference_number)
    
    # Merge results from both groups
    # Note: this currently doesn't let us compare how many amendment groups were generated by each method. We could check that by selecting amendment groups and finding non-matching d_procurement_id values.
    matching_reference_numbers <- unique(c(matching_reference_numbers_by_d_procurement_id, matching_reference_numbers_by_original_value_and_start_date))
    
    # Update the amendment groups tibble (not used beyond this yet)
    amendment_groups <- amendment_groups %>% 
      add_row(
        origin_reference_number = current_contract$d_reference_number, 
        amendment_reference_number = matching_reference_numbers, # (character vector with, in some cases, multiple amendment reference numbers)
      )
    
    # 3. Update the corresponding rows
    # Note: not sure if there's a way to avoid the repetition below.
    contracts <- contracts %>%
      mutate(
        d_amendment_group_id = case_when(
          d_reference_number %in% matching_reference_numbers ~ current_contract$d_reference_number,
          TRUE ~ d_amendment_group_id, # Leave it at its previous value if it doesn't match.
        ),
        d_is_amendment = case_when(
          d_reference_number %in% matching_reference_numbers ~ TRUE,
          TRUE ~ d_is_amendment, # Same here, leave it at its previous value if it doesn't match.
        ),
      )
    
    # 4. Update the original contract to include the d_amendment_group_id
    # (but not a d_is_amendment flag)
    if(length(matching_reference_numbers) >= 1) {
      contracts <- contracts %>%
        mutate(
          d_amendment_group_id = case_when(
            d_reference_number == current_contract$d_reference_number ~ current_contract$d_reference_number,
            TRUE ~ d_amendment_group_id,
          ),
        )
    }
    
  }
  
  return(contracts)

}



# Version 2, using group_by functions
find_amendment_groups_v2 <- function(contracts) {
  # To identify amendment groups, the approach is:
  # same owner_org
  # same vendor (once normalized)
  # same d_procurement_id
  # OR
  # same owner_org
  # same vendor (once normalized)
  # original_value == contract_value of the original row(?)
  # same start date (to confirm if derived values / closest year helps)
  
  # *not* part of an existing amendment group
  
  # New columns added
  contracts <- contracts %>%
    mutate(
      d_is_amendment = FALSE,
      d_amendment_group_id = NA_character_,
      d_number_of_amendments = NA_integer_,
      d_amendment_via = NA_character_,
    )
  
  contracts <- contracts %>%
    group_by(owner_org, d_vendor_name, d_procurement_id) %>%
    mutate(
      d_amendment_group_id = first(d_reference_number),
      d_number_of_amendments = n() - 1,
      d_amendment_via = case_when(
        is.na(d_amendment_via) & d_number_of_amendments >= 1 ~ "procurement_id", # for d_procurement_id
        TRUE ~ d_amendment_via,
      ),
    ) %>%
    ungroup()
  
  # Second case (matching original values & start dates)
  
  # Ensure that there's an "original value" to compare to, even in the first contract's case where it might only be listed in contract_value
  contracts <- contracts %>%
    mutate(
      d_original_original_value = case_when(
        original_value > 0 ~ original_value, # Also takes care of NA entries
        TRUE ~ contract_value
      )
    )
  
  # Note: Need to be careful here not to accidentally interfere with
  # contracts that were previously grouped in the first case.
  contracts <- contracts %>%
    group_by(owner_org, d_vendor_name, d_original_original_value, d_start_date) %>%
    mutate(
      d_amendment_group_id = case_when(
        is.na(d_amendment_via) ~ first(d_reference_number),
        TRUE ~ d_amendment_group_id,
      ),
      d_number_of_amendments = case_when(
        is.na(d_amendment_via) ~ n() - 1,
        TRUE ~ d_number_of_amendments,
      ),
      d_amendment_via = case_when(
        is.na(d_amendment_via) & d_number_of_amendments >= 1 ~ "original_value", # for original value + start date
        TRUE ~ d_amendment_via,
      ),
    ) %>%
    ungroup()
  
  
  # For both cases at once, flag amendment entries
  contracts <- contracts %>%
    mutate(
      d_is_amendment = case_when(
        d_amendment_group_id != d_reference_number ~ TRUE,
        TRUE ~ d_is_amendment, # Don't change the previous value, if the line above isn't true.
      )
    )
  
  return(contracts)
  
}
