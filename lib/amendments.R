# Handler functions to match together amendment groups
# in Government of Canada contracting data

# Note: is it bad form to load these multiple times? Does it cheerfully ignore repeats?
# Update: appears to be, all good.
source("lib/_libraries.R")


find_amendment_groups_v1 <- function(contracts) {
  # To identify amendment groups, the approach is:
  # same owner_org
  # same vendor (once normalized)
  # same procurement_id
  # OR
  # same owner_org
  # same vendor (once normalized)
  # original_value == contract_value of the original row(?)
  # same start date (to confirm if derived values / closest year helps)
  
  # *not* part of an existing amendment group
  
  # New columns added
  # d_is_amendment
  # d_amendment_group_id
  contracts <- contracts %>%
    mutate(
      d_is_amendment = FALSE,
      d_amendment_group_id = NA_character_,
    )
  
  # Amendment finding across all contracts:
  reference_numbers <- contracts %>% pull(d_reference_number)
  
  # Create a temporary array that matches origin contract reference numbers
  # to amendment reference numbers.
  # This would be a nested array of different lengths if we were doing it in PHP!
  amendment_groups <- tibble(origin_reference_number = character(), amendment_reference_number = character())
  
  for (i in seq_along(reference_numbers)) {
    
    # 1. Pull up the current contract
    current_contract <- contracts %>%
      filter(
        d_reference_number == reference_numbers[[i]]
      ) %>%
      slice_head()
    
    # 2A. Find the matching contracts by procurement_id
    matching_reference_numbers_by_procurement_id <- contracts %>%
      filter(
        d_reference_number != current_contract$d_reference_number, # Don't re-select the same row
        owner_org == current_contract$owner_org,
        vendor_name == current_contract$vendor_name,
        procurement_id == current_contract$procurement_id,
        is.na(d_amendment_group_id), # Don't re-run existing amendments
      ) %>%
      pull(d_reference_number)
    
    # 2B. Find the matching contracts by original value and start date
    matching_reference_numbers_by_original_value_and_start_date <- contracts %>%
      filter(
        d_reference_number != current_contract$d_reference_number, # Don't re-select the same row
        owner_org == current_contract$owner_org,
        vendor_name == current_contract$vendor_name,
        original_value == current_contract$contract_value,
        d_start_date == current_contract$d_start_date, # Note: does normalizing the start date have unexpected consequences here? Do amendments sometimes have new, later, start dates?
        is.na(d_amendment_group_id), # Don't re-run existing amendments
      ) %>%
      pull(d_reference_number)
    
    # Merge results from both groups
    # Note: this currently doesn't let us compare how many amendment groups were generated by each method. We could check that by selecting amendment groups and finding non-matching procurement_id values.
    matching_reference_numbers <- unique(c(matching_reference_numbers_by_procurement_id, matching_reference_numbers_by_original_value_and_start_date))
    
    # Update the amendment groups tibble (not used beyond this yet)
    amendment_groups <- amendment_groups %>% 
      add_row(
        origin_reference_number = current_contract$d_reference_number, 
        amendment_reference_number = matching_reference_numbers, # (character vector with, in some cases, multiple amendment reference numbers)
      )
    
    # 3. Update the corresponding rows
    # Note: not sure if there's a way to avoid the repetition below.
    contracts <- contracts %>%
      mutate(
        d_amendment_group_id = case_when(
          d_reference_number %in% matching_reference_numbers ~ current_contract$d_reference_number,
          TRUE ~ d_amendment_group_id, # Leave it at its previous value if it doesn't match.
        ),
        d_is_amendment = case_when(
          d_reference_number %in% matching_reference_numbers ~ TRUE,
          TRUE ~ d_is_amendment, # Same here, leave it at its previous value if it doesn't match.
        ),
      )
    
    # 4. Update the original contract to include the d_amendment_group_id
    # (but not a d_is_amendment flag)
    if(length(matching_reference_numbers) >= 1) {
      contracts <- contracts %>%
        mutate(
          d_amendment_group_id = case_when(
            d_reference_number == current_contract$d_reference_number ~ current_contract$d_reference_number,
            TRUE ~ d_amendment_group_id,
          ),
        )
    }
    
  }
  
  return(contracts)

}
